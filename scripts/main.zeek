module CVE_2022_26809;

export {
	redef enum Log::ID += {
		LOG
	};
	redef enum Notice::Type += {
		ExploitAttempt,
		ExploitSuccess
	};
	type Info: record {
		ts: time &log;
		uid: string &log;
		regex: string &log;
		data: string &log;
	};
}

# Malicious byte strings
global big_endian = /..\x0c.\x00\x00\x00\x00/;
global big_endian_specific = /\x05\x00\x0c\x03\x00\x00\x00\x00/;

# Normal byte strings
global little_endian = /..\x0c.\x10\x00\x00\x00/;
global little_endian_specific = /\x05\x00\x0c\x03\x10\x00\x00\x00/;

event dce_rpc_request_stub(c: connection, fid: count, ctx_id: count,
    opnum: count, stub: string)
{
	# EfsRpcDecryptFileSrv
	if ( opnum == 5 ) {
		local v: vector of string;
		local ip = cat(c$id$orig_h);
		v += "\\";
		v += "\\";
		for ( char in cat(c$id$orig_h) ) {
			v += char;
		}
		local s = join_string_vec(v, "\x01");
		s = gsub(s, /\x01/, "\x00");
		if ( strstr(stub, s) > 0 ) {
			NOTICE([
			    $note=ExploitAttempt,
			    $msg=fmt("%s attempting exploit on %s", c$id$orig_h, c$id$resp_h),
			    $sub=fmt("Using opnum %d", opnum),
			    $identifier=cat(c$id$orig_h, c$id$resp_h)]);
		}
	}
}

# To make the weak regex more robust, go to a known offset for frag_length that
# should be equal to the size of the packet's data after finding the beginning
# of the DCERPC data, i.e., the first byte of the regex match.
function correct_frag_length(data: string, regex: pattern): bool
{
	local mres = match_pattern(data, regex);
	if ( ! mres$matched )
		return F;

	# mres$off - 1 is the offset to the start of the DCERPC section
	# 8 bytes until we hit frag length
	local start = mres$off - 1 + 8;
	local end = mres$off - 1 + 10;
	if ( end > |data| )
		return F;
	local frag_len_bytes = data[start:end];
	if ( |frag_len_bytes| == 0 )
		return F;

	local frag_len = bytestring_to_count(data[start:end]);

	return frag_len == |data| - mres$off + 1;
}

# Should work if Zeek parsed malformed Bind ACKs correctly.
event dce_rpc_bind_ack(c: connection, fid: count, sec_addr: string)
{
	local pkt = get_current_packet();
	if ( big_endian_specific in pkt$data && correct_frag_length(pkt$data,
	    big_endian_specific) )
		Log::write(LOG, Info(
		    $ts=network_time(),
		    $uid=c$uid,
		    $regex="big_endian_specific",
		    $data=pkt$data));
	if ( big_endian in pkt$data && correct_frag_length(pkt$data,
	    big_endian_specific) )
		Log::write(LOG, Info(
		    $ts=network_time(),
		    $uid=c$uid,
		    $regex="big_endian",
		    $data=pkt$data));
}
# Main event
event dce_rpc_message(c: connection, is_orig: bool, fid: count, ptype_id: count,
    ptype: DCE_RPC::PType)
{
	if ( ptype != DCE_RPC::BIND_ACK )
		return;
	#if ( ! c?$dce_rpc || ! c$dce_rpc?$named_pipe || ! c$dce_rpc?$endpoint )
	#		return;
	#if ( c$dce_rpc$named_pipe != "\pipe\lsass"
	#    || c$dce_rpc$endpoint != "efsrpc2" )
	#		return;
	# c$dce_rpc and c$dce_rpc_state are unfortunately not populated yet, so
	# we cannot check for those to make the detection more robust.
	local pkt = get_current_packet();
	if ( big_endian_specific in pkt$data && correct_frag_length(pkt$data,
	    big_endian_specific) ) {
		NOTICE([
		    $note=ExploitSuccess,
		    $msg=fmt("%s exploited %s", c$id$orig_h, c$id$resp_h),
		    $sub="Found via big_endian_specific (in dce_rpc_message)",
		    $identifier=cat(c$id$orig_h, c$id$resp_h)]);
	}
	if ( big_endian in pkt$data && correct_frag_length(pkt$data, big_endian) ) {
		NOTICE([
		    $note=ExploitSuccess,
		    $msg=fmt("%s exploited %s", c$id$orig_h, c$id$resp_h),
		    $sub="Found via big_endian (in dce_rpc_message)",
		    $identifier=cat(c$id$orig_h, c$id$resp_h)]);
	}
}

event zeek_init() &priority=5
{
	Log::create_stream(CVE_2022_26809::LOG, [
	    $columns=Info,
	    $path="cve_2022_26809_dce_rpc_bind_ack_data"]);
}
